<!DOCTYPE html>
<html lang="ja">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta charset="UTF-8">
  <title>DBMS種牡馬データ検索(仮テスト中)</title>

  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    /* タイトル直下にリリース情報を表示 */
    #release-info {
      margin-bottom: 20px;
      font-size: 14px;
    }
    .container {
      display: flex;
    }
    /* 左パネル=幅2/5、右パネル=幅3/5 */
    .left-panel {
      width: 30%;
      padding: 10px;
      border-right: 2px solid #ccc;
    }
    .right-panel {
      width: 70%;
      padding: 10px;
      overflow-x: auto; /* テーブルだけ横スクロール */
    }
    .pedigree {
      width: 100%;
      border-collapse: collapse;
      text-align: center;
      margin-bottom: 20px;
    }
    .pedigree td {
      border: 1px solid black;
      padding: 5px;
    }
    .horse {
      width: 100%;
    }
    .horse select {
      width: 100%;
    }
    #dataTable {
      width: 100%;
      min-width: 800px;
    }
    thead select {
      width: 100%;
      box-sizing: border-box;
    }
    .dataTable {
      width: 100%;
    }

    /* DataTables 上部配置（左=牡馬/牝馬, 右=show entries + search） */
    .dt-top { display: flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap; }
    .dt-right { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
    .dt-sex-filter label { margin-right: 12px; white-space: nowrap; }
  
/* ==== Mobile fix v6: prevent left panel expanding + stack generation selects ==== */
@media (max-width: 640px){
  /* モバイルでは左右を縦積み（はみ出し/押し出し防止） */
  .container{ flex-direction: column !important; }
  .left-panel, .right-panel{ width: 100% !important; }
  .left-panel{ border-right: none !important; min-width: 0 !important; }
  .right-panel{ min-width: 0 !important; }

  /* 代数フィルタ部分だけ縦積み + 幅100% */
  #genFilterGrid{ display:block !important; width:100% !important; }
  #genFilterGrid label{ display:block !important; width:100% !important; margin:10px 0 4px 0 !important; }
  #genFilterGrid select{
    display:block !important;
    width:100% !important;
    max-width:100% !important;
    min-width:0 !important; /* flexのmin-content問題対策 */
    box-sizing:border-box !important;
  }
}

/* --- SPST子系統 tab --- */
#tab-spst-child .spst-block { margin: 8px 0 10px; }
#tab-spst-child .spst-title { font-weight: 600; display:block; margin-bottom:6px; }
#tab-spst-child select { width: 100%; box-sizing: border-box; }
#tab-spst-child .spst-actions { margin-top: 6px; }
#tab-spst-child button { padding: 6px 10px; }


/* --- SPST子系統 tab (v4) --- */
#tab-spst-child .spst-head{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px; }
#tab-spst-child .spst-head h3{ margin:0; }
#tab-spst-child .spst-block{ margin: 8px 0 12px; }
#tab-spst-child .spst-title{ font-weight:600; display:block; margin-bottom:6px; }
#tab-spst-child select{ width:100%; box-sizing:border-box; }
#tab-spst-child .spst-row{ display:flex; gap:6px; margin-top:6px; }
#tab-spst-child .spst-row select{ flex:1 1 auto; min-width:0; }
#tab-spst-child button{ padding:6px 10px; }


/* 因名フィルタ */
.dt-sex-filter select#filterIname { height: 28px; }
.dt-sex-filter .sex-checks { display:flex; align-items:center; flex-wrap:wrap; gap:8px; }


/* SPST反映トグル */
#tab-spst-child .spst-head-actions{ display:flex; gap:8px; align-items:center; }
#tab-spst-child #spstToggle{ font-weight:600; }


/* SPST子系統 追加行の縦幅を抑える */
#tab-spst-child .spst-row{ align-items:center; }
#tab-spst-child .spst-row button{ white-space:nowrap; writing-mode:horizontal-tb; line-height:1.2; padding:6px 10px; }
#tab-spst-child .spst-row select{ height:28px; }


/* --- SPST子系統 레이아웃調整（以前のv8系レイアウトに寄せる） --- */
#tab-spst-child .spst-section{ width:100%; }
#tab-spst-child .spst-list{ width:100%; box-sizing:border-box; }
#tab-spst-child .spst-row{
  display:flex;
  align-items:center;
  gap:8px;
  width:100%;
}
#tab-spst-child .spst-row select{
  flex:1 1 auto;
  min-width: 160px;
  width:100%;
  box-sizing:border-box;
}
#tab-spst-child .spst-row .spst-row-buttons{
  display:flex;
  gap:8px;
  flex:0 0 auto;
}
#tab-spst-child .spst-row button{
  height:28px;
  padding:6px 10px;
  line-height:1.1;
  white-space:nowrap;
  writing-mode:horizontal-tb;
}



/* ==== (スマホ/狭幅) SPST子系統 追加行を縦積み & 代数プルダウンを見出しの下に固定 ==== */
@media (max-width: 900px){
  /* SPST子系統：追加プルダウンの下にボタンを配置（枠内に収める） */
  #tab-spst-child .spst-row{ display:block !important; }
  #tab-spst-child .spst-row select{ width:100% !important; min-width:0 !important; }
  #tab-spst-child .spst-row-buttons{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
  #tab-spst-child .spst-row-buttons button{ white-space:nowrap; }

  /* 代数タブ：各ラベルの直下にプルダウン（右テーブルにはみ出さない） */
  #tab-generation .gen-filter-grid{
    display:block !important;
    width:100% !important;
    max-width:100% !important;
  }
  #tab-generation .gen-filter-row{ display:block !important; }
  #tab-generation .gen-filter-grid label{
    display:block !important;
    width:100% !important;
    margin:10px 0 4px 0 !important;
  }
  #tab-generation .gen-filter-grid select{
    display:block !important;
    width:100% !important;
    max-width:100% !important;
    min-width:0 !important;
    box-sizing:border-box !important;
  }
  #tab-generation .gen-filter-clear{ margin-top:10px !important; }
}


/* ===== SPST mobile visible list (iOS/Android) ===== */
.spst-mobile-list{ display:none; border:1px solid #bbb; border-radius:3px; background:#fff; max-height: 240px; overflow:auto; padding:2px; box-sizing:border-box; }
.spst-mobile-item{ display:block; width:100%; text-align:left; border:0; background:transparent; padding:6px 8px; font-size:14px; line-height:1.2; }
.spst-mobile-item + .spst-mobile-item{ border-top:1px solid #eee; }
.spst-mobile-item.is-selected{ background:#dbeeff; }
@media (max-width: 900px){
  #spstSpeedSelect, #spstStaminaSelect{ display:none; }
  #spstSpeedMobileList, #spstStaminaMobileList{ display:block; }
}
</style>

  <style>
    /* --- Tabs for left pedigree area --- */
    .tabs-left__nav { display:flex; gap:8px; margin:6px 0 8px; }
    .tabs-left__btn { padding:6px 12px; border:1px solid #ccc; background:#f7f7f7; border-radius:6px; cursor:pointer; }
    .tabs-left__btn.is-active { background:#fff; border-color:#888; font-weight:600; }
    .tabs-left__pane { display:none; }
    .tabs-left__pane.is-active { display:block; }
    .gen-filter-grid { display:grid; grid-template-columns: 140px 1fr auto; gap:8px 12px; align-items:center; max-width: 980px; }
    .gen-filter-row { display:contents; }
    .gen-filter-grid label { white-space:nowrap; }
    .gen-filter-grid select { min-width: 220px; }
    .gen-filter-actions { margin-top: 6px; }
    .hr { border-top: 1px solid #ddd; margin: 8px 0 12px; }
  </style>


  <style>
    /* --- Adjusted grid for generation tab --- */
    .gen-filter-grid { display:grid; grid-template-columns: 220px 1fr; gap:10px 14px; align-items:center; max-width: 980px; }
    .gen-filter-grid label { white-space: normal; line-height:1.4; }
    .gen-filter-grid select { width: 100%; min-width: 240px; }
    .gen-filter-clear { grid-column: 1 / -1; margin-top: 4px; }
    /* --- Tab visual emphasis --- */
    .tabs-left__nav { display:flex; gap:8px; margin:6px 0 8px; border-bottom: 1px solid #ddd; }
    .tabs-left__btn { padding:8px 14px; border:1px solid #ccc; background:#f9f9f9; border-top-left-radius:10px; border-top-right-radius:10px; cursor:pointer; }
    .tabs-left__btn.is-active { background:#fff; border-color:#888; border-bottom-color:#fff; box-shadow: 0 -1px 0 #fff inset; font-weight:600; }
    .ped-tabs { border:1px solid #ddd; border-radius:10px; padding:8px; background:#fff; }
    .tabs-left__pane { margin-top:6px; }
  
/* ==== Mobile: SPST子系統 追加/削除ボタンをプルダウンの下に配置 ==== */
@media (max-width: 640px){
  #tab-spst-child .spst-row{ display:block !important; }
  #tab-spst-child .spst-row select{ width:100% !important; min-width:0 !important; }
  #tab-spst-child .spst-row-buttons{ display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
  #tab-spst-child .spst-row-buttons button{ white-space:nowrap; }
}
</style>

</head>
<body>
  <h2>DBMS種牡馬データ検索(仮テスト中)</h2>
  <!-- 追加：タイトル直下にリリース情報を表示 -->
  <div id="release-info">
    <p>2025/02/11：リリース</p>
    <p id="update-date">データ最終更新日：不明</p>
  </div>

  <div class="container">
    <!-- =====================
         左パネル（変更なし）
         ===================== -->
    <div class="left-panel">
      
    <div class="ped-tabs">
      <div class="tabs-left__nav">
        <button class="tabs-left__btn is-active" data-tab="tab-pedigree">血統表</button>
        <button class="tabs-left__btn" data-tab="tab-spst-child">SPST子系統</button>
        <button class="tabs-left__btn" data-tab="tab-generation">代数</button>
      </div>

<div id="tab-pedigree" class="tabs-left__pane is-active">
        <h3>血統表</h3>
      <!-- 血統表 (15セル) -->
      <table class="pedigree" id="tbl-pedigree">
        <tbody>
          <tr><td rowspan="8">父</td><td class="horse" colspan="4"></td></tr>
          <tr><td rowspan="4">父</td><td class="horse" colspan="3"></td></tr>
          <tr><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="3">母</td><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="7">母</td><td rowspan="4">父</td><td class="horse" colspan="3"></td></tr>
          <tr><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="3">母</td><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
        </tbody>
      </table>

      <h3>親系統</h3>
      <!-- 親系統 (15セル pa:) -->
      <table class="pedigree" id="tbl-parent">
        <tbody>
          <tr><td rowspan="8">父</td><td class="horse" colspan="4"></td></tr>
          <tr><td rowspan="4">父</td><td class="horse" colspan="3"></td></tr>
          <tr><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="3">母</td><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="7">母</td><td rowspan="4">父</td><td class="horse" colspan="3"></td></tr>
          <tr><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="3">母</td><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
        </tbody>
      </table>

      <h3>子系統</h3>
      <!-- 子系統 (15セル chi:) -->
      <table class="pedigree" id="tbl-child">
        <tbody>
          <tr><td rowspan="8">父</td><td class="horse" colspan="4"></td></tr>
          <tr><td rowspan="4">父</td><td class="horse" colspan="3"></td></tr>
          <tr><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="3">母</td><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="7">母</td><td rowspan="4">父</td><td class="horse" colspan="3"></td></tr>
          <tr><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
          <tr><td rowspan="3">母</td><td rowspan="2">父</td><td class="horse" colspan="2"></td></tr>
          <tr><td>父</td><td class="horse"></td></tr>
          <tr><td>母</td><td>父</td><td class="horse"></td></tr>
        </tbody>
      </table>
    
      </div>

<div id="tab-spst-child" class="tabs-left__pane">
        <div class="spst-head">
          <h3>SPST子系統</h3>
          <div class="spst-head-actions"><button type="button" id="spstToggle">未反映</button>
</div>
        </div>

        <div class="spst-block">
          <label class="spst-title"><input type="checkbox" id="spstSpeedEnabled" checked> スピード子系統</label>
          <select id="spstSpeedSelect" multiple size="12"></select>
          <div id="spstSpeedMobileList" class="spst-mobile-list" aria-label="スピード子系統 選択リスト"></div>
          <div class="spst-row">
            <select id="spstSpeedAddSelect"></select>
            <div class="spst-row-buttons"><button type="button" id="spstSpeedAddBtn">追加</button>
            <button type="button" id="spstSpeedDelBtn">削除</button>
            <button type="button" id="spstSpeedClearBtn">全削除</button>
            <button type="button" id="spstSpeedResetBtn">デフォ復帰</button></div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="spst-block">
          <label class="spst-title"><input type="checkbox" id="spstStaminaEnabled" checked> スタミナ子系統</label>
          <select id="spstStaminaSelect" multiple size="12"></select>
          <div id="spstStaminaMobileList" class="spst-mobile-list" aria-label="スタミナ子系統 選択リスト"></div>
          <div class="spst-row">
            <select id="spstStaminaAddSelect"></select>
            <div class="spst-row-buttons"><button type="button" id="spstStaminaAddBtn">追加</button>
            <button type="button" id="spstStaminaDelBtn">削除</button>
            <button type="button" id="spstStaminaClearBtn">全削除</button>
            <button type="button" id="spstStaminaResetBtn">デフォ復帰</button></div>
          </div>
        </div>
      </div>

<div id="tab-generation" class="tabs-left__pane">
        <h3>代数</h3>
        <div class="gen-filter-grid" id="genFilterGrid">
          <div class="gen-filter-row">
            <label>2代目（父）</label>
            <select id="gen2Select"><option value="">選択</option></select>
            

            <label>3代目（父父 / 母父）</label>
            <select id="gen3Select"><option value="">選択</option></select>
            

            <label>4代目（父父父、等）</label>
            <select id="gen4Select"><option value="">選択</option></select>
            

            <label>5代目（父父父父、等）</label>
            <select id="gen5Select"><option value="">選択</option></select>

  <label for="genAllSelect">全世代（2〜5代内すべて）</label>
  <select id="genAllSelect"><option value="">選択</option></select>
<div class="gen-filter-clear">
  <button id="btnGenClear" type="button">クリア（代数フィルタ）</button>
</div>
            
          </div>
        </div>
        <div class="hr"></div>
      </div>
</div>
    
    </div>

    <div class="right-panel">
      <table id="dataTable" class="display dataTable">
        <thead></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script>
    // =========================
    // 1. 定義
    // =========================
    const CSV_URL = "./mydata.csv";
    let table;
    let columnMap = {};
    let originalData = [];

    // 右側のプルダウン用列（「馬名」以外は既存通り）
    const filterHeaders = [ "系統","親系統","子系統","category","距離","成長","ダート","体質","気性","実績","底力","安定","天性" ];

    // 血統表(15) + 親系統(15) + 子系統(15) = 45 <td class="horse">
    const pedigreeHeaders = [
      "父","父父","父父父","父父父父","父父母父",
      "父母父","父母父父","父母母父",
      "母父","母父父","母父父父","母父母父",
      "母母父","母母父父","母母母父"
    ];
    const parentHeaders = [
      "pa:父","pa:父父","pa:父父父","pa:父父父父","pa:父父母父",
      "pa:父母父","pa:父母父父","pa:父母母父","pa:母父",
      "pa:母父父","pa:母父父父","pa:母父母父",
      "pa:母母父","pa:母母父父","pa:母母母父"
    ];
    const childHeaders = [
      "chi:父","chi:父父","chi:父父父","chi:父父父父","chi:父父母父",
      "chi:父母父","chi:父母父父","chi:父母母父","chi:母父",
      "chi:母父父","chi:母父父父","chi:母父母父",
      "chi:母母父","chi:母母父父","chi:母母母父"
    ];
    const allHeaders = pedigreeHeaders.concat(parentHeaders).concat(childHeaders);

    // 左側・右側のフィルタをそれぞれ記録(列index -> 値)
    const leftFilters  = {};
    const rightFilters = {};

    // =========================
    // 2. CSVを自動読み込み（CSV更新日時を取得して更新日表示）
    // =========================
    document.addEventListener("DOMContentLoaded", () => {
      fetch(CSV_URL)
        .then(res => {
          let lastModified = res.headers.get("Last-Modified");
          let dateStr = "不明";
          if(lastModified){
            let dateObj = new Date(lastModified);
            let year = dateObj.getFullYear();
            let month = ("0" + (dateObj.getMonth()+1)).slice(-2);
            let day = ("0" + dateObj.getDate()).slice(-2);
            dateStr = `${year}/${month}/${day}`;
          }
          document.getElementById("update-date").innerText = "データ最終更新日：" + dateStr;
          return res.text();
        })
        .then(csvText => initTable(csvText))
        .catch(err => console.error("CSV読み込み失敗:", err));
    });
      // =========================
      // SPST子系統（子系統列フィルタ）
      // =========================
      const SPST_SPEED_DEFAULT = [
        "ハビタット系","ボールドルーラー系","フェアトライアル系","クラリオン系","プリンスビオ系","トムフール系","エクリプス系","ダンテ系",
        "オーエンテューダー系","ニアークティック系","ネアルコ系","インテント系","ブランドフォード系"
      ];
      const SPST_STAMINA_DEFAULT = [
        "ハイペリオン系","ブレニム系","ネヴァーセイダイ系","プリンスキロ系","モスボロー系","サーゲイロード系","ヒムヤー系","テディ系",
        "オリオール系","フォルティノ系","ナスルーラ系","ニアークティック系"
      ];

      let spstSpeedSet = new Set(SPST_SPEED_DEFAULT);
      let spstStaminaSet = new Set(SPST_STAMINA_DEFAULT);

      // SPST子系統 フィルタ反映ON/OFF（デフォルト: 未反映）
      let spstActive = false;


      
function initSpstChildOptions(){
        const colIdx = columnMap["子系統"];
        if(colIdx === undefined) return;

        // collect unique child lines
        const uniq = new Set();
        originalData.forEach(r => {
          const v = (r[colIdx] ?? "").toString().trim();
          if(v) uniq.add(v);
        });
        const allValues = Array.from(uniq).sort((a,b)=>a.localeCompare(b,'ja'));

        const speedList = document.getElementById("spstSpeedSelect");
        const stamList  = document.getElementById("spstStaminaSelect");
        const speedAdd  = document.getElementById("spstSpeedAddSelect");
        const stamAdd   = document.getElementById("spstStaminaAddSelect");
        if(!speedList || !stamList || !speedAdd || !stamAdd) return;

        function renderList(listEl, currentSet){
          listEl.innerHTML = "";
          Array.from(currentSet).sort((a,b)=>a.localeCompare(b,'ja')).forEach(v=>{
            const opt = document.createElement("option");
            opt.value = v;
            opt.textContent = v;
            listEl.appendChild(opt);
          });
          renderSpstMobileList(listEl);

        }

        const __spstMobileMap = {
          "spstSpeedSelect": "spstSpeedMobileList",
          "spstStaminaSelect": "spstStaminaMobileList"
        };

        function renderSpstMobileList(listEl){
          const cid = __spstMobileMap[listEl.id];
          if(!cid) return;
          const container = document.getElementById(cid);
          if(!container) return;

          // Only show on narrow screens (CSS also handles)
          container.innerHTML = "";
          const opts = Array.from(listEl.options);
          if(opts.length === 0){
            // empty state
            const empty = document.createElement("div");
            empty.style.padding = "6px 8px";
            empty.style.color = "#666";
            empty.textContent = "（なし）";
            container.appendChild(empty);
            return;
          }

          opts.forEach(opt=>{
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "spst-mobile-item" + (opt.selected ? " is-selected" : "");
            btn.textContent = opt.textContent;
            btn.addEventListener("click", ()=>{
              // toggle selection like <select multiple>
              opt.selected = !opt.selected;
              btn.classList.toggle("is-selected", opt.selected);
            });
            container.appendChild(btn);
          });
        }

        function renderAdd(addEl, currentSet){
          addEl.innerHTML = "";
          const candidates = allValues.filter(v => !currentSet.has(v));
          if(candidates.length === 0){
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "(追加候補なし)";
            addEl.appendChild(opt);
            addEl.disabled = true;
          }else{
            addEl.disabled = false;
            candidates.forEach(v=>{
              const opt = document.createElement("option");
              opt.value = v;
              opt.textContent = v;
              addEl.appendChild(opt);
            });
          }
        }

        // 初期表示：デフォルトで指定された子系統のみ
        renderList(speedList, spstSpeedSet);
        renderList(stamList,  spstStaminaSet);
        renderAdd(speedAdd, spstSpeedSet);
        renderAdd(stamAdd,  spstStaminaSet);

        // 追加/削除（リスト編集のみ。フィルタ反映は「反映」ボタンで実施）
        document.getElementById("spstSpeedAddBtn")?.addEventListener("click", ()=>{
          const v = (speedAdd.value ?? "").toString().trim();
          if(!v) return;
          spstSpeedSet.add(v);
          renderList(speedList, spstSpeedSet);
          renderAdd(speedAdd, spstSpeedSet);
          if(spstActive) table.draw();
        });
        document.getElementById("spstStaminaAddBtn")?.addEventListener("click", ()=>{
          const v = (stamAdd.value ?? "").toString().trim();
          if(!v) return;
          spstStaminaSet.add(v);
          renderList(stamList, spstStaminaSet);
          renderAdd(stamAdd, spstStaminaSet);
          if(spstActive) table.draw();
        });

        document.getElementById("spstSpeedDelBtn")?.addEventListener("click", ()=>{
          const selected = Array.from(speedList.selectedOptions).map(o=>o.value);
          selected.forEach(v=>spstSpeedSet.delete(v));
          renderList(speedList, spstSpeedSet);
          renderAdd(speedAdd, spstSpeedSet);
          if(spstActive) table.draw();
        });
        document.getElementById("spstStaminaDelBtn")?.addEventListener("click", ()=>{
          const selected = Array.from(stamList.selectedOptions).map(o=>o.value);
          selected.forEach(v=>spstStaminaSet.delete(v));
          renderList(stamList, spstStaminaSet);
          renderAdd(stamAdd, spstStaminaSet);
          if(spstActive) table.draw();
        });


        // 全削除 / デフォ復帰（リスト編集のみ。反映中なら即draw）
        document.getElementById("spstSpeedClearBtn")?.addEventListener("click", ()=>{
          spstSpeedSet.clear();
          renderList(speedList, spstSpeedSet);
          renderAdd(speedAdd, spstSpeedSet);
          if(spstActive) table.draw();
        });
        document.getElementById("spstStaminaClearBtn")?.addEventListener("click", ()=>{
          spstStaminaSet.clear();
          renderList(stamList, spstStaminaSet);
          renderAdd(stamAdd, spstStaminaSet);
          if(spstActive) table.draw();
        });

        document.getElementById("spstSpeedResetBtn")?.addEventListener("click", ()=>{
          spstSpeedSet.clear();
          SPST_SPEED_DEFAULT.forEach(v=>spstSpeedSet.add(v));
          renderList(speedList, spstSpeedSet);
          renderAdd(speedAdd, spstSpeedSet);
          if(spstActive) table.draw();
        });
        document.getElementById("spstStaminaResetBtn")?.addEventListener("click", ()=>{
          spstStaminaSet.clear();
          SPST_STAMINA_DEFAULT.forEach(v=>spstStaminaSet.add(v));
          renderList(stamList, spstStaminaSet);
          renderAdd(stamAdd, spstStaminaSet);
          if(spstActive) table.draw();
        });


        
        // 反映ON/OFFトグル（デフォルト: 未反映）
        (function(){
          const btn = document.getElementById('spstToggle');
          if(!btn) return;
          const update = ()=>{ btn.textContent = spstActive ? '反映中' : '未反映'; };
          update();
          btn.addEventListener('click', ()=>{
            spstActive = !spstActive;
            update();
            table.draw();
          });
        })();

        // スピ/スタの有効チェックのON/OFFも、反映中なら即テーブルへ同期
        document.getElementById("spstSpeedEnabled")?.addEventListener("change", ()=>{
          if(spstActive) table.draw();
        });
        document.getElementById("spstStaminaEnabled")?.addEventListener("change", ()=>{
          if(spstActive) table.draw();
        });
      }


    function initTable(csvText){
      const lines = csvText.split(/\r?\n/).filter(line => line.trim() !== "");
      const headerRow = lines[0].split(",");
      const dataRows  = lines.slice(1)
                        .map(line => line.split(","))
                        .filter(row => row.length === headerRow.length);

      headerRow.forEach((col, i) => { columnMap[col] = i; });
      originalData = dataRows;
      initSpstChildOptions();





      // DataTablesヘッダー生成（1行目=列名, 2行目=フィルタ<select>）
      // ※「link」列は非表示
      let firstRow = "<tr>" + headerRow.map(h => {
        return h === "link" ? `<th style="display:none">${h}</th>` : `<th>${h}</th>`;
      }).join("") + "</tr>";
      let secondRow = "<tr>" + headerRow.map(h => {
        if(h === "link"){
          return `<th style="display:none"></th>`;
        }
        if(h === "馬名"){
          // ここで馬名専用プルダウンを追加
          return `<th class='colfilter-horse' data-col='${h}'><select><option value=''>すべて</option></select></th>`;
        }
        if(filterHeaders.includes(h)) {
          return `<th class='colfilter' data-col='${h}'><select><option value=''>すべて</option></select></th>`;
        } else {
          return "<th></th>";
        }
      }).join("") + "</tr>";
      document.querySelector("#dataTable thead").innerHTML = firstRow + secondRow;

      // DataTablesの列定義（馬名列はリンク付きに変換）
      let columnsDef = headerRow.map((h, idx) => {
        if(h === "馬名"){
          return {
            title: h,
            render: function(data, type, row, meta) {
              const linkIndex = columnMap["link"];
              let url = row[linkIndex] || "#";
              return `<a href="${url}" target="_blank">${data}</a>`;
            }
          };
        } else {
          return { title: h };
        }
      });

      if($.fn.DataTable.isDataTable("#dataTable")){
        $("#dataTable").DataTable().destroy();
      }
      table = $("#dataTable").DataTable({
        data: dataRows,
        columns: columnsDef,
        columnDefs: [
          { targets: columnMap["link"], visible: false }
        ],
        scrollX: true,
        orderCellsTop: true,
        dom: '<"dt-top"<"dt-sex-filter"><"dt-right"lf>>rt<"bottom"ip><"clear">',
      });

      // (v7) DataTables描画後に左パネル（血統表/親系統/子系統）プルダウンを常に同期
      // SPST子系統など table.draw() のみで更新されるケースでも、検索適用後データに追随させる
      table.on('draw', function(){
        try{
          let dtRows = table.rows({search:'applied'}).data().toArray();
          updateAllSelects(dtRows);
        }catch(e){}
      });


      // --- 牡馬/牝馬チェックボックス（距離の空/非空で絞り込み） ---
      (function(){
        // 左側（元 show entries の位置）にチェックボックスを配置
                const $sex = $('<div class="sex-checks">' +
          '<label><input type="checkbox" id="filterMale" checked>牡馬</label>' +
          '<label><input type="checkbox" id="filterFemale" checked>牝馬</label>' +
          '<label style="margin-left:8px;">因名 ' +
            '<select id="filterIname" style="min-width:120px;">' +
              '<option value="">すべて</option>' +
            '</select>' +
          '</label>' +
          '<label style="margin-left:8px;"><input type="checkbox" id="filterSho">走因子</label>' +
          '<label style="margin-left:8px;"><input type="checkbox" id="filterOu">中因子</label>' +
          '<label style="margin-left:8px;"><input type="checkbox" id="filter3">3因子のみ表示</label>' +
        '</div>');
        $('.dt-sex-filter').empty().append($sex);

        // 「距離」列を特定
        const distanceCol = table.columns().header().toArray().findIndex(h => $(h).text().trim() === '距離');


        // 「馬名」列を特定（因名抽出元）
        const horseNameCol = table.columns().header().toArray().findIndex(h => $(h).text().trim() === '馬名');

        // 因名（-漢字2文字-）抽出関数
        function extractInameFromHorseName(name){
          const s = (name ?? '').toString();
          const m = s.match(/-([\u4e00-\u9fff]{2})-/);
          return m ? m[1] : '';
        }

        // 因名プルダウンを初期化（ユニーク値）
        (function initInameDropdown(){
          if(horseNameCol < 0) return;
          const set = new Set();
          originalData.forEach(r => {
            const nm = r[horseNameCol];
            const iname = extractInameFromHorseName(nm);
            if(iname) set.add(iname);
          });
          const vals = Array.from(set).sort((a,b)=>a.localeCompare(b,'ja'));
          const $sel = $('#filterIname');
          vals.forEach(v => $sel.append($('<option>').val(v).text(v)));
        })();

        const THREE_FACTOR_SET = new Set([
          "天煌","天禊","天闘","天靭",
          "央叡","央天","央燕","央獅","央瑚","央瓏","央迅","央魂",
          "煉禊","煌魂",
          "燕巧","燕禊","燕闘","燕順",
          "獅煌","獅禊","獅闘",
          "瑚巧","瑚狂","瑚闘",
          "瓏禊","瓏覇","瓏闘",
          "瞬天","瞬神",
          "神煌","神狂","神速",
          "翔叡","翔天","翔燕","翔獅","翔瑚","翔瓏","翔迅","翔魂",
          "覇閃","覇魂",
          "迅闘",
          "閃煌","閃禊",
          "闘神"
        ]);


        // DataTables カスタムフィルタ
        $.fn.dataTable.ext.search.push(function(settings, data){
          if(settings.nTable !== table.table().node()) return true;

          const male = $('#filterMale').prop('checked');
          const female = $('#filterFemale').prop('checked');

          // 性別フィルタは「条件の一部」として判定（他フィルタも通す）
          let sexPass = true;

const v = (distanceCol >= 0 ? (data[distanceCol] ?? '') : '').toString().trim();
          const hasDistance = v !== '';


          // ---- 因名フィルタ ----
          let iname = '';
          if(horseNameCol >= 0){
            iname = extractInameFromHorseName(data[horseNameCol] ?? '');
          }

          // 因名プルダウン（完全一致）
          const inameSel = ($('#filterIname').val() ?? '').toString().trim();
          if(inameSel && iname !== inameSel) return false;

          // 因子チェック（複数ONの場合は OR）
          const fSho = $('#filterSho').prop('checked');
          const fOu  = $('#filterOu').prop('checked');
          const f3   = $('#filter3').prop('checked');

          if(fSho || fOu || f3){
            let ok = false;
            if(fSho && iname.includes('翔')) ok = true;
            if(fOu  && iname.includes('央')) ok = true;
            if(f3   && THREE_FACTOR_SET.has(iname)) ok = true;
            if(!ok) return false;
          }


          // 牡馬のみ：距離がブランクでない
          if(male && !female) sexPass = hasDistance;

          // 牝馬のみ：距離がブランク
          if(!male && female) sexPass = !hasDistance;

          return sexPass;
        });

        $('#filterMale, #filterFemale, #filterIname, #filterSho, #filterOu, #filter3').on('change', function(){
          table.draw();
        });
      })();


      // --- SPST子系統フィルタ（子系統列の OR フィルタ） ---
      (function(){
        // DataTables ext.search に追加（既存フィルタはそのまま）
        $.fn.dataTable.ext.search.push(function(settings, data){
          if(settings.nTable !== table.table().node()) return true;

          // SPSTタブの反映がOFFなら何もしない
          if(!spstActive) return true;


          const colIdx = columnMap["子系統"];
          if(colIdx === undefined) return true;

          const speedOn = $('#spstSpeedEnabled').prop('checked');
          const stamOn  = $('#spstStaminaEnabled').prop('checked');

          // 両方OFFならフィルタ無し
          if(!speedOn && !stamOn) return true;

          const v = (data[colIdx] ?? '').toString().trim();
          if(!v) return false;

          // 両方ON：和集合（OR）
          if(speedOn && stamOn){
            return spstSpeedSet.has(v) || spstStaminaSet.has(v);
          }
          if(speedOn){
            return spstSpeedSet.has(v);
          }
          // stamina only
          return spstStaminaSet.has(v);
        });

        function readMultiSelect(sel){
          return new Set(Array.from(sel.selectedOptions).map(o=>o.value));
        }

        // 反映ボタン（どちらを押しても同じ反映）
        // (v4) apply handled by #spstApplyAll

      })();


      // 左側プルダウン生成（既存処理）
      updateAllSelects(dataRows);

      // 右側ヘッダー2行目<select> の選択肢生成
      populateColumnFilters(headerRow, dataRows);
      // 馬名専用プルダウン生成（抽出したハイフンで囲まれた漢字）
      populateHorseNameFilter(dataRows);

      // 右側<select>のイベント設定
      document.querySelectorAll(".colfilter select").forEach(sel => {
        sel.addEventListener("change", onChangeHeaderSelect);
      });
      document.querySelector(".colfilter-horse select").addEventListener("change", onChangeHorseFilter);
    }

    // =========================
    // 3. 右ヘッダー2行目 <select> → DataTables検索
    // =========================
    function populateColumnFilters(headerRow, dataRows){
      headerRow.forEach(colName => {
        if(!filterHeaders.includes(colName)) return;
        let colIndex = columnMap[colName];
        if(colIndex === undefined) return;
        let th = document.querySelector(`.colfilter[data-col='${colName}']`);
        if(!th) return;
        let sel = th.querySelector("select");
        if(!sel) return;

        let uniqueVals = sortCandidates([...new Set(dataRows.map(r => r[colIndex]))] );
        let opts = "<option value=''>すべて</option>" +
          uniqueVals.map(v => `<option value="${v}">${v}</option>`).join("");
        sel.innerHTML = opts;
      });
    }

    function onChangeHeaderSelect(e){
      let colName = e.target.parentElement.getAttribute("data-col");
      let colIndex = columnMap[colName];
      if(colIndex !== undefined){
        if(e.target.value){
          rightFilters[colIndex] = e.target.value;
        } else {
          delete rightFilters[colIndex];
        }
      }
      applyAllFilters();
    }

    // =========================
    // 追加：馬名専用プルダウンの生成とイベントハンドラ
    // =========================
    function populateHorseNameFilter(dataRows){
      let colIndex = columnMap["馬名"];
      if(colIndex === undefined) return;
      let sel = document.querySelector(".colfilter-horse select");
      if(!sel) return;
      let values = [];
      dataRows.forEach(r => {
        let text = r[colIndex];
        let match = text.match(/-([\u4e00-\u9faf]+)-/);
        if(match){
          values.push(match[1]);
        }
      });
      let uniqueVals = sortCandidates([...new Set(values)] );
      let opts = "<option value=''>すべて</option>" +
             uniqueVals.map(v => `<option value="${v}">${v}</option>`).join("");
      sel.innerHTML = opts;
    }
    function onChangeHorseFilter(e){
      let colName = e.target.parentElement.getAttribute("data-col");
      let colIndex = columnMap[colName];
      if(colIndex !== undefined){
        if(e.target.value){
          // 馬名列は「含む」検索に変更
          rightFilters[colIndex] = e.target.value;
        } else {
          delete rightFilters[colIndex];
        }
      }
      applyAllFilters();
    }

    // =========================
    // 4. 左パネルプルダウン（既存処理）
    // =========================
    function updateAllSelects(dataRows){
      const horseCells = document.querySelectorAll(".horse");

      // 既存の選択を保持
      let oldSelections = [];
      horseCells.forEach((cell, i) => {
        let sel = cell.querySelector("select");
        oldSelections[i] = sel ? sel.value : "";
      });

      // 再生成
      horseCells.forEach((cell, i) => {
        let sel = cell.querySelector("select");
        if(!sel){
          sel = document.createElement("select");
          cell.appendChild(sel);
        }
        let headerName = allHeaders[i];
        let colIndex = columnMap[headerName];
        if(colIndex === undefined){
          sel.innerHTML = "<option value=''>選択</option>";
          return;
        }
        let uniqueVals = sortCandidates([...new Set(dataRows.map(r => r[colIndex]))] );
        let opts = "<option value=''>選択</option>" +
          uniqueVals.map(v => `<option value="${v}">${v}</option>`).join("");
        sel.innerHTML = opts;
      });

      // 選択を復元
      horseCells.forEach((cell, i) => {
        let sel = cell.querySelector("select");
        if(!sel) return;
        let oldVal = oldSelections[i];
        if(oldVal && [...sel.options].some(o => o.value === oldVal)){
          sel.value = oldVal;
        } else {
          sel.value = "";
        }
      });
    }

    document.addEventListener("change", e => {
      if(e.target.matches(".horse select")){
        applyLinkedFilter();
      }
    });
    function applyLinkedFilter(){
      // 左パネルの選択を leftFilters に反映
      const horseCells = document.querySelectorAll(".horse");
      horseCells.forEach((cell, i) => {
        let sel = cell.querySelector("select");
        if(!sel) return;
        let val = sel.value;
        let headerName = allHeaders[i];
        let colIndex = columnMap[headerName];
        if(colIndex !== undefined){
          if(val){
            leftFilters[colIndex] = val;
          } else {
            delete leftFilters[colIndex];
          }
        }
      });
      applyAllFilters();
    }

    // =========================
    // 5. 左右フィルタを AND でDataTables検索
    // =========================
    function applyAllFilters(){
      let horseColIndex = columnMap["馬名"];
      table.columns().every(function(colIdx){
        const leftVal  = leftFilters[colIdx];
        const rightVal = rightFilters[colIdx];
        let pattern = "";
        if(colIdx === horseColIndex) {
          if(leftVal && rightVal){
            if(leftVal === rightVal){
              pattern = `.*${leftVal}.*`;
            } else {
              pattern = '^$';
            }
          } else if(leftVal){
            pattern = `.*${leftVal}.*`;
          } else if(rightVal){
            pattern = `.*${rightVal}.*`;
          }
        } else {
          if(leftVal && rightVal){
            if(leftVal === rightVal){
              pattern = `^${leftVal}$`;
            } else {
              pattern = '^$';
            }
          } else if(leftVal){
            pattern = `^${leftVal}$`;
          } else if(rightVal){
            pattern = `^${rightVal}$`;
          }
        }
        this.search(pattern, true, false);
      });

      table.draw();

      // フィルタ後の行データに合わせて左パネルプルダウンを再生成
      let dtRows = table.rows({search:'applied'}).data().toArray();
      updateAllSelects(dtRows);
    }
  </script>

<script>
(function(){
  const GEN_SLOTS = {
    2: ["父"],
    3: ["父父", "母父"],
    4: ["父父父", "父母父", "母父父", "母母父"],
    5: ["父父父父", "父父母父", "父母父父", "父母母父", "母父父父", "母父母父", "母母父父", "母母母父"]
  };

  const GEN_SLOTS_ALL = [...GEN_SLOTS[2], ...GEN_SLOTS[3], ...GEN_SLOTS[4], ...GEN_SLOTS[5]];


  function setupTabs(){
    const btns = document.querySelectorAll(".tabs-left__btn");
    const panes = document.querySelectorAll(".tabs-left__pane");
    btns.forEach(btn => {
      btn.addEventListener("click", () => {
        btns.forEach(b => b.classList.remove("is-active"));
        panes.forEach(p => p.classList.remove("is-active"));
        btn.classList.add("is-active");
        const id = btn.getAttribute("data-tab");
        document.getElementById(id).classList.add("is-active");
      });
    });
  }

  // Resolve the right-side DataTable instance
  function getRightDT(){
    // Prefer global 'table', else by id 'dataTable'
    if (window.table && typeof window.table.rows === 'function') return window.table;
    const node = document.getElementById('dataTable');
    if (node && $.fn.dataTable.isDataTable(node)) return $(node).DataTable();
    return null;
  }

  // Build a header->index map; prefer existing columnMap, else compute from DataTable headers
  function resolveColumnMap(dt){
    if (window.columnMap && typeof window.columnMap === 'object') return window.columnMap;
    const map = {};
    const headers = dt.columns().header();
    for (let i=0; i<headers.length; i++){
      const name = headers[i].textContent.trim();
      if (name && map[name] === undefined) map[name] = i;
    }
    return map;
  }

  // Collect options from ALL rows for the given slot headers
  function collectOptionsForSlots(dt, colMap, slotHeaders) {
const set = new Set();
    const allRows = dt.rows().data().toArray(); // all rows, unfiltered
    slotHeaders.forEach(hdr => {
      const ci = colMap[hdr];
      if (ci === undefined) return;
      for (const row of allRows){
        const v = (row[ci] || '').toString().trim();
        if (v) set.add(v);
      




}
    });
    return sortCandidates(Array.from(set));
  }

  function populateSelect(sel, values){
    const keep = sel.value;
    sel.innerHTML = '<option value=\"\">選択</option>' +
      values.map(v=>`<option value=\"${v}\">${v}</option>`).join('');
    if (keep && values.includes(keep)) sel.value = keep;
  }

  
  function buildAllGenerationFilter(dt, colMap, value){
    const headers = GEN_SLOTS_ALL;
    const fn = function(settings, data, dataIndex){
      if (settings.nTable !== dt.table().node()) return true;
      if (!value) return true;
      // Accept if value matches ANY of the headers (2〜5代のOR)
      for (const hdr of headers){
        const ci = colMap[hdr];
        if (ci === undefined) continue;
        const cell = (data[ci] || '').toString().trim();
        if (cell && cell === value) return true;
      }
      return false;
    };
    fn.__GEN_FILTER__ = true;
    return fn;
  }

  function buildGenerationFilter(dt, colMap, state){
    const fn = function(settings, data, dataIndex){
      if (settings.nTable !== dt.table().node()) return true;
      for (const genKey of Object.keys(state)){
        const target = state[genKey];
        if (!target) continue;
        const slots = GEN_SLOTS[genKey];
        if (!slots || !slots.length) continue;
        let ok = false;
        for (const hdr of slots){
          const ci = colMap[hdr];
          if (ci === undefined) continue;
          const cell = (data[ci] || '').toString().trim();
          if (cell && cell === target){ ok = true; break; }
        }
        if (!ok) return false;
      }
      return true;
    };
    fn.__GEN_FILTER__ = true;
    return fn;
  }

  function onceReady(cb){
    const start = Date.now();
    const timer = setInterval(() => {
      const dt = getRightDT();
      const ready = !!dt && dt.rows().count() > 0;
      if (ready){
        clearInterval(timer);
        cb(dt);
      }else if (Date.now() - start > 15000){
        clearInterval(timer);
        console.warn('Generation filters: timeout waiting for DataTable data.');
      }
    }, 100);
  }

  document.addEventListener('DOMContentLoaded', function(){
    setupTabs();

    onceReady(function(dt){
      const colMap = resolveColumnMap(dt);
      const gen2 = document.getElementById('gen2Select');
      const gen3 = document.getElementById('gen3Select');
      const gen4 = document.getElementById('gen4Select');
      const gen5 = document.getElementById('gen5Select');
      const genAll = document.getElementById('genAllSelect');
      if(!(gen2 && gen3 && gen4 && gen5)) return;

      function rebuildAllGenOptions(){
        populateSelect(gen2, collectOptionsForSlots(dt, colMap, GEN_SLOTS[2]));
        populateSelect(gen3, collectOptionsForSlots(dt, colMap, GEN_SLOTS[3]));
        populateSelect(gen4, collectOptionsForSlots(dt, colMap, GEN_SLOTS[4]));
        populateSelect(gen5, collectOptionsForSlots(dt, colMap, GEN_SLOTS[5]));
        if (genAll) populateSelect(genAll, collectOptionsForSlots(dt, colMap, GEN_SLOTS_ALL));
      }
      rebuildAllGenOptions();

      const state = { 2:'', 3:'', 4:'', 5:'' };
      let allVal = '';
      function applyGenFilter(){
        $.fn.dataTable.ext.search = $.fn.dataTable.ext.search.filter(fn => !fn.__GEN_FILTER__);
        if (allVal){
          $.fn.dataTable.ext.search.push(buildAllGenerationFilter(dt, colMap, allVal));
        } else if (Object.values(state).some(v=>!!v)){
          $.fn.dataTable.ext.search.push(buildGenerationFilter(dt, colMap, state));
        }
        dt.draw();
      }

      [['2',gen2],['3',gen3],['4',gen4],['5',gen5]].forEach(([k,sel])=>{
        sel.addEventListener('change', e => {
          state[k] = e.target.value.trim();
          if (state[k]){ allVal = ''; if(genAll) genAll.value=''; }
          applyGenFilter();
        });
      });

      if (genAll){
        genAll.addEventListener('change', e => {
          allVal = e.target.value.trim();
          if (allVal){
            state['2']=state['3']=state['4']=state['5']='';
            gen2.value = gen3.value = gen4.value = gen5.value = '';
          }
          applyGenFilter();
        });
      }

      const clearBtn = document.getElementById('btnGenClear');
      if (clearBtn){
        clearBtn.addEventListener('click', ()=>{
          state['2']=state['3']=state['4']=state['5']='';
          gen2.value = gen3.value = gen4.value = gen5.value = '';
          if (genAll){ allVal=''; genAll.value=''; }
          applyGenFilter();
        });
      }

      // If the underlying data is reloaded (Ajax), refresh options again
      $(dt.table().node()).on('xhr.dt', function(){ setTimeout(rebuildAllGenOptions, 0); });
    });
  });
})();
</script>


<script>
// -- Unified candidate sorter: Japanese < English(ASCII Latin-only) < Others; within Japanese, 'ウ' < 'ヴ'
(function(){
  if (window.__HAS_SORT_CANDIDATES__) return;
  window.__HAS_SORT_CANDIDATES__ = true;

  window.sortCandidates = function(inputArr){
    const collJaBase = new Intl.Collator('ja', { usage: 'sort', sensitivity: 'base', numeric: true });
    const collJaVar  = new Intl.Collator('ja', { usage: 'sort', sensitivity: 'variant', numeric: true });
    const collEn     = new Intl.Collator('en', { usage: 'sort', sensitivity: 'base', numeric: true });
    const stripZW = (s) => (s || '').replace(/[\u200B-\u200D\uFEFF]/g, '');
    const normalize = (s) => stripZW((s || '').normalize('NFKC').trim());
    const hasJapanese = (s) => /[\u3040-\u30FF\u4E00-\u9FFF]/.test(s); // kana/hira/kanji
    const isAsciiLatinOnly = (s) => /^[\x00-\x7F]*[A-Za-z][\x00-\x7F]*$/.test(s);

    const arr = Array.from(inputArr || []);
    arr.sort((aRaw, bRaw) => {
      const a = normalize(aRaw);
      const b = normalize(bRaw);
      const ga = hasJapanese(a) ? 0 : (isAsciiLatinOnly(a) ? 1 : 2);
      const gb = hasJapanese(b) ? 0 : (isAsciiLatinOnly(b) ? 1 : 2);
      if (ga !== gb) return ga - gb;

      if (ga === 0) {
        const baseCmp = collJaBase.compare(a, b);
        if (baseCmp !== 0) return baseCmp;
        const aHasVu = a.includes('ヴ');
        const bHasVu = b.includes('ヴ');
        if (aHasVu !== bHasVu) return aHasVu ? 1 : -1;
        return collJaVar.compare(a, b);
      }
      if (ga === 1) {
        return collEn.compare(a, b);
      }
      return collJaVar.compare(a, b);
    });
    return arr;
  };
})();
</script>

</body>
</html>